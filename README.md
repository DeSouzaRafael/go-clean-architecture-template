
# Go Clean Architecture Template

Clean Architecture template for Golang

[![codecov](https://codecov.io/gh/DeSouzaRafael/go-clean-architecture-template/branch/main/graph/badge.svg?token=PNP58LYNPA)](https://codecov.io/gh/DeSouzaRafael/go-clean-architecture-template)
[![Go Report Card](https://goreportcard.com/badge/github.com/DeSouzaRafael/go-clean-architecture-template)](https://goreportcard.com/report/github.com/DeSouzaRafael/go-clean-architecture-template)
[![License](https://img.shields.io/github/license/evrone/go-clean-template.svg)](https://github.com/DeSouzaRafael/go-clean-architecture-template/blob/main/LICENSE)
[![GitHub Release](https://img.shields.io/github/v/release/DeSouzaRafael/go-clean-architecture-template)](https://github.com/DeSouzaRafael/go-clean-architecture-template/releases/)

## Overview

This project is a clean architecture template written in Go, designed to provide a scalable and maintainable structure for Go applications. It aims to:
- Separate concerns cleanly across layers.
- Implement a consistent pattern for dependency injection.
- Provide a foundation for RESTful APIs.
- Facilitate the use of PostgreSQL as the primary data store.

## Content
- [Quick Start](#quick-start)
- [Project Structure](#project-structure)
  - [cmd/app](#cmdapp)
  - [config](#config)
  - [docs](#docs)
  - [infra](#infra)
    - [httpserver](#infrahttpserver)
    - [logger](#infralogger)
    - [postgres](#infrapostgres)
    - [validator](#infravalidator)
  - [internal](#internal)
    - [app](#internalapp)
    - [controller](#internalcontroller)
      - [rest](#internalcontrollerrest)
    - [entity](#internalentity)
    - [usecase](#internalusecase)
- [Dependency Injection](#dependency-injection)
- [Clean Architecture](#clean-architecture)
  - [Key Idea](#key-idea)

## Quick Start
Local development:
```sh
# start postgres and run app
$ make run
```

## Project Structure

### `cmd/app`
Contains the entry point for the application. The `main.go` file loads environment variables and hands over control to the `Run` function in `internal/app`.

### `config`
`config.go` where I'm setting up a structure to define my variables to be used during application initialization.

For configuration, we chose the [godotenv](https://github.com/joho/godotenv) library. It's very simple and meets all the requirements.

### `docs`
Swagger documentation. Auto-generated by [swag](https://github.com/swaggo/swag) library.
You don't need to adjust anything inside the file/directory.

### `infra`
Contains infrastructure code for the application.

#### `infra/httpserver`
Provides the HTTP server setup using the Echo framework. Main components include:

- `options.go`: Contains configuration options for the server.
- `server.go`: Initializes and runs the HTTP server.

#### `infra/logger`
Provides a logging mechanism for the application.

#### `infra/postgres`
Contains PostgreSQL database connectivity and repository patterns.

- `repository`: Houses the base repository and specific repositories.

#### `infra/validator`
Implements data validation using the "validator" library.
It allows for validating data structures against predefined rules. The `NewValidator()` method initializes a new validator, registering custom validations. The `Validate()` method performs validation on a data structure and returns validation errors if any. Additionally, the code includes functions for registering and formatting custom validation errors.

### `internal`
Contains the core business logic and components.

#### `internal/app`
The `app.go` file always contains a `Run` function that continues the execution from the main function.

Here, all the main objects are created, and dependency injection occurs through the "New..." constructors (see in [Dependency Injection](#dependency-injection)). 
This technique helps structure the application following the Dependency Injection principle, ensuring that business logic remains independent of other layers.

Next, we start the server and use a `select` statement to listen for signals, enabling graceful shutdown. If `app.go` starts to grow too much, consider splitting it into multiple files.

For migrations, as we're using [GORM](https://gorm.io/), we can use the `AutoMigrate` option. Just call the models, and you're done.

For example:

```go
	if err := pg.DB.AutoMigrate(
		&entity.UserEntity{},
		// add models
	)
```

#### `internal/controller`
Handles RESTful API requests and responses:
- REST http ([Echo framework](https://echo.labstack.com/))

- `input`: Defines input structures for API requests.
- `output`: Defines output structures for API responses.
- `routers/v0`: Implements versioned routing.

#### `internal/controller/rest`
Simple REST versioning.
For v1, we'll need to add the `rest/routers/v1` folder with the same content. 
Additionally, insert the following line into the `rest/router.go` file:
```go
	// REST versioning
	v0.NewUserRoutes(h, l, v, uc.UserUseCase())
	v1.NewOtherRoutes(h, l, v, uc.OtherUseCase())
```

In `v0/user_view.go`, above the handler methods, there are comments guiding the generation of Swagger documentation using [swag](https://github.com/swaggo/swag).

#### `internal/entity`
Entities of business logic (models) can be used across any layer. 
However, I refrain from employing them directly in API responses as I find it unnecessary to list control fields `(created_at/updated_at/deleted_at)`.
For such scenarios, I have established the `input/output` folders in the `internal/controller/rest` directory.

#### `internal/usecase`
Business logic.
- Methods are categorized by their respective areas of application, following a standardized approach.
- Each category adheres to its specific structure.
- One structure is maintained per file.

Injecting repositories, WebAPI, RPC, and other business logic structures into the core of business operations
(see [Dependency Injection](#dependency-injection)).

## Dependency Injection
To decouple business logic from external packages, dependency injection is employed.
For instance, via the New constructor, we inject dependencies into the business logic structure.

This fosters independence and portability within the business logic. Consequently, altering the implementation of the interface doesn't necessitate modifications to the `usecase` package.

```go
package usecase

type Repository interface {
    Get()
}

type UseCase struct {
    repo Repository
}

func New(r Repository) *UseCase {
    return &UseCase{
        repo: r,
    }
}

func (uc *UseCase) Do() {
    uc.repo.Get()
}
```

## Clean Architecture

### Key Idea
The main objective of the clean architecture is to ensure that the business logic remains independent of any framework or external library. The template is structured with this principle in mind:

 - Entities: Core business models that can be shared across layers.
 - Use Cases: Business logic interacting with entities and repositories.
 - Controllers: Serve as adapters for input/output.
 - Infrastructure: Provides database connectivity, server setup, etc.