
# Clean Template

Clean Architecture template for Golang

[![codecov](https://codecov.io/gh/DeSouzaRafael/go-clean-architecture-template/branch/main/graph/badge.svg?token=PNP58LYNPA)](https://codecov.io/gh/DeSouzaRafael/go-clean-architecture-template)
[![Go Report Card](https://goreportcard.com/badge/github.com/DeSouzaRafael/go-clean-architecture-template)](https://goreportcard.com/report/github.com/DeSouzaRafael/go-clean-architecture-template)
[![License](https://img.shields.io/github/license/evrone/go-clean-template.svg)](https://github.com/DeSouzaRafael/go-clean-architecture-template/blob/main/LICENSE)
[![GitHub Release](https://img.shields.io/github/v/release/DeSouzaRafael/go-clean-architecture-template)](https://github.com/DeSouzaRafael/go-clean-architecture-template/releases/)

## Overview
-

## Content
- 

## Quick start
Local development:
```sh
# start postgres and run app
$ make run
```

## Project structure
`cmd/app/main.go`

Execution begins by loading the environments, after which the main function proceeds in 
`internal/app/app.go`.


### `config`
`config.go` where I'm setting up a structure to define my variables to be used during application initialization.

For configuration, we chose the [godotenv](github.com/joho/godotenv) library. It's very simple and meets all the requirements.

### `docs`
Swagger documentation. Auto-generated by [swag](https://github.com/swaggo/swag) library.
You don't need to adjust anything inside the file/directory.

### `internal/app`
The `app.go`  file always contains a Run function that continues the execution from the main function

Here, all the main objects are created, and dependency injection occurs through the "New..." constructors (see [Dependency Injection](#dependency-injection)). This technique helps structure the application following the Dependency Injection principle, ensuring that business logic remains independent of other layers.

Next, we start the server and use a `select` statement to listen for signals, enabling graceful shutdown. If `app.go` starts to grow too much, consider splitting it into multiple files.

For migrations, as we're using [GORM](https://gorm.io/), we can use the `AutoMigrate` option. Just call the models, and you're done.


For example:

```go
	if err := pg.DB.AutoMigrate(
		&entity.UserEntity{},
		// add models
	)
```

### `internal/controller`
Server handler layer (MVC controllers). The template shows server:
- REST http ([Echo framework](https://echo.labstack.com/))

Server routes follow the same style:
- Handlers are grouped by application area (based on a shared basis)
- Each group has its own router structure, with methods that handle specific paths
- The business logic structure is injected into the router structure, which is then called by the handlers


#### `internal/controller/rest`
Simple REST versioning.
For v1, we'll need to add the `rest/routers/v1` folder with the same content. 
Additionally, insert the following line into the `rest/router.go` file:
```go
	// REST versioning
	v0.NewUserRoutes(h, l, v, uc.UserUseCase())
	v1.NewOtherRoutes(h, l, v, uc.OtherUseCase())
```

In `v0/user_view.go`, above the handler methods, there are comments guiding the generation of Swagger documentation using [swag](https://github.com/swaggo/swag).

### `internal/entity`
Entities of business logic (models) can be used across any layer. 
However, I refrain from employing them directly in API responses as I find it unnecessary to list control fields `(created_at/updated_at/deleted_at)`.
For such scenarios, I have established the `input/output` folders in the `internal/controller/rest` directory.